# Zod Validation Implementation for ShikshaConnect

## Overview

This project implements Zod validation for all POST and PUT API endpoints to ensure data integrity, security, and consistency across the application. The validation schemas are shared between client and server-side components.

## ğŸ“¦ Installation & Setup

### Dependencies Added
- `zod`: ^3.23.8 - Runtime type validation library
- `@prisma/client`: Latest version - Database client
- `autoprefixer`: Latest - CSS post-processing
- `tailwindcss`: Latest - Utility-first CSS framework

### Installation Commands
```bash
npm install zod --legacy-peer-deps
npm install @prisma/client --save --legacy-peer-deps
npm install @tailwindcss/postcss autoprefixer --legacy-peer-deps
```

## ğŸ—ï¸ Project Structure

```
src/
â”œâ”€â”€ libs/
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â””â”€â”€ userSchema.ts      # Shared validation schemas
â”‚   â”œâ”€â”€ validationHandler.ts   # Zod error handling utilities
â”‚   â”œâ”€â”€ prisma.ts             # Database client
â”‚   â”œâ”€â”€ responseHandler.ts    # Response utilities
â”‚   â””â”€â”€ errorCodes.ts         # Error code definitions
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ user/route.ts     # User API with validation
â”‚   â”‚   â””â”€â”€ test/route.ts     # Test API with validation
```

## ğŸ“‹ Validation Schemas

### User Schema (`src/libs/schemas/userSchema.ts`)

```typescript
import { z } from "zod";

// User schema for validation (matches the existing API structure)
export const userSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters long"),
  email: z.string().email("Invalid email address"),
  total: z.number().min(1, "Total must be greater than 0").max(1000000, "Total cannot exceed 1,000,000"),
});

// Test data schema
export const testSchema = z.object({
  title: z.string().min(1, "Title is required").max(100, "Title cannot exceed 100 characters"),
  description: z.string().min(10, "Description must be at least 10 characters long").max(500, "Description cannot exceed 500 characters"),
  category: z.enum(["frontend", "backend", "fullstack", "devops"]),
  difficulty: z.enum(["beginner", "intermediate", "advanced"])
});

// Shared types inferred from schemas
export type UserInput = z.infer<typeof userSchema>;
export type TestInput = z.infer<typeof testSchema>;
```

## ğŸ”§ Error Handling (`src/libs/validationHandler.ts`)

```typescript
import { ZodError } from "zod";
import type { ZodIssue } from "zod";

export interface ValidationError {
  field: string;
  message: string;
}

export interface ValidationResponse {
  success: false;
  message: string;
  errors: ValidationError[];
}

export function handleZodError(error: ZodError): ValidationResponse {
  const errors = error.errors.map((err: ZodIssue) => ({
    field: err.path.join('.'),
    message: err.message
  }));

  return {
    success: false,
    message: "Validation Error",
    errors
  };
}
```

## ğŸ›¡ï¸ API Implementation Examples

### User API Route (`src/app/api/user/route.ts`)

```typescript
import { NextResponse } from "next/server";
import { prisma } from "@/libs/prisma";
import { sendSuccess, sendError } from "@/libs/responseHandler";
import { ERROR_CODES } from "@/libs/errorCodes";
import { userSchema } from "@/libs/schemas/userSchema";
import { handleZodError } from "@/libs/validationHandler";

export async function POST(req: Request) {
  try {
    const body = await req.json();
    
    // Validate input using Zod schema
    const validatedData = userSchema.parse(body);

    const result = await prisma.$transaction(async (tx) => {
      const user = await tx.user.create({
        data: { 
          name: validatedData.name, 
          email: validatedData.email 
        },
      });

      const order = await (tx as any).order.create({
        data: {
          total: validatedData.total,
          userId: user.id,
        },
      });

      return { user, order };
    });

    return sendSuccess(result, "Transaction successful", 201);
  } catch (error: any) {
    if (error.name === "ZodError") {
      // Handle Zod validation errors
      const validationErrors = handleZodError(error);
      return NextResponse.json(validationErrors, { status: 400 });
    }
    
    console.error("Transaction failed:", error);
    return sendError("Transaction failed", ERROR_CODES.TRANSACTION_FAILED, 500, error);
  }
}
```

## ğŸ§ª Testing Validation

### Successful Request Example

**curl command:**
```bash
curl -X POST http://localhost:3000/api/user \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com","total":100}'
```

**Expected Success Response:**
```json
{
  "success": true,
  "data": {
    "user": { "id": 1, "name": "Alice", "email": "alice@example.com" },
    "order": { "id": 1, "total": 100, "userId": 1 }
  },
  "message": "Transaction successful"
}
```

### Validation Error Examples

#### 1. Missing Required Fields

**Request:**
```bash
curl -X POST http://localhost:3000/api/user \
  -H "Content-Type: application/json" \
  -d '{"name":"A","email":"invalid-email"}'
```

**Expected Error Response:**
```json
{
  "success": false,
  "message": "Validation Error",
  "errors": [
    { "field": "name", "message": "Name must be at least 2 characters long" },
    { "field": "email", "message": "Invalid email address" },
    { "field": "total", "message": "Total must be greater than 0" }
  ]
}
```

#### 2. Invalid Data Types

**Request:**
```bash
curl -X POST http://localhost:3000/api/user \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com","total":"not-a-number"}'
```

**Expected Error Response:**
```json
{
  "success": false,
  "message": "Validation Error",
  "errors": [
    { "field": "total", "message": "Expected number, received string" }
  ]
}
```

#### 3. Boundary Violations

**Request:**
```bash
curl -X POST http://localhost:3000/api/user \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com","total":0}'
```

**Expected Error Response:**
```json
{
  "success": false,
  "message": "Validation Error",
  "errors": [
    { "field": "total", "message": "Total must be greater than 0" }
  ]
}
```

## ğŸ”„ Schema Reuse Benefits

### 1. **Client-Side Validation**
The same schemas can be used in React components for client-side validation before API calls:

```typescript
import { userSchema } from "@/libs/schemas/userSchema";

const FormComponent = () => {
  const handleSubmit = (data: FormData) => {
    try {
      const validatedData = userSchema.parse(data);
      // Submit to API
    } catch (error) {
      // Handle validation errors
    }
  };
};
```

### 2. **Type Safety**
With `z.infer`, you get TypeScript types from your Zod schemas:

```typescript
export type UserInput = z.infer<typeof userSchema>;
// TypeScript automatically knows the shape of valid user data
```

### 3. **Consistency**
Both client and server validate the same rules, preventing inconsistent data validation.

## ğŸ“Š Best Practices Implemented

1. **Descriptive Error Messages**: Each validation rule has clear, actionable error messages
2. **Structured Error Response**: All validation errors return in a consistent format
3. **Type Safety**: Full TypeScript support through type inference
4. **Reusable Schemas**: Single source of truth for validation rules
5. **Graceful Error Handling**: Proper error boundaries and fallbacks
6. **Boundary Validation**: Range checking for numeric values (min/max)
7. **Format Validation**: Email format and string length validation

## ğŸš€ Benefits Achieved

### Security Improvements
- **Input Sanitization**: Prevents malicious input from reaching the database
- **Type Safety**: Ensures data types match expected formats
- **Boundary Protection**: Prevents overflow values and extreme inputs

### Development Benefits
- **Better Developer Experience**: Clear error messages and type hints
- **Reduced Debugging**: Early validation catches issues before database operations
- **Documentation**: Schemas serve as living documentation of expected input formats
- **Maintainability**: Single source of truth for validation rules

### Production Benefits
- **Database Integrity**: Ensures only valid data reaches the database
- **API Consistency**: Consistent error responses across all endpoints
- **Performance**: Early validation prevents unnecessary database operations
- **Monitoring**: Validation failures can be tracked for security analysis

## ğŸ¯ Next Steps

1. **Add More Schemas**: Create schemas for other API endpoints
2. **Client Integration**: Implement client-side validation using the same schemas
3. **Automated Testing**: Add unit tests for validation scenarios
4. **Monitoring**: Set up logging for validation failure patterns
5. **Documentation**: Expand API documentation with validation examples

## ğŸ“ Reflection on Maintainability

This Zod validation implementation significantly improves maintainability by:

- **Centralizing Validation Logic**: All validation rules exist in one place
- **Reducing Code Duplication**: Same schemas work on client and server
- **Improving Error Consistency**: All endpoints return structured validation errors
- **Enhancing Team Collaboration**: Shared schemas improve communication between frontend and backend developers
- **Facilitating Refactoring**: Schema changes automatically propagate to all usage points
- **Simplifying Testing**: Validation scenarios can be tested independently of business logic

The implementation demonstrates enterprise-level data validation patterns that scale well with application growth and team size.
